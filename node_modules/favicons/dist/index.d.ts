import { Transform } from 'stream';
import sharp from 'sharp';

declare type Dictionary<T> = {
    [key: string]: T;
};
declare type RawImage = {
    data: Buffer;
    info: sharp.OutputInfo;
};

interface IconSize {
    readonly width: number;
    readonly height: number;
}
interface IconOptions {
    readonly sizes: IconSize[];
    readonly offset?: number;
    readonly background?: string | boolean;
    readonly transparent: boolean;
    readonly rotate: boolean;
    readonly purpose?: string;
    readonly pixelArt?: boolean;
}
interface FileOptions {
    readonly manifestFileName?: string;
}
interface ShortcutOptions {
    readonly name: string;
    readonly short_name?: string;
    readonly description?: string;
    readonly url: string;
    readonly icon?: string | string[] | Buffer | Buffer[];
}
interface Application {
    readonly platform?: string;
    readonly url?: string;
    readonly id?: string;
}
interface OutputOptions {
    readonly images?: boolean;
    readonly files?: boolean;
    readonly html?: boolean;
}
interface FaviconOptions {
    readonly path?: string;
    readonly appName?: string;
    readonly appShortName?: string;
    readonly appDescription?: string;
    readonly developerName?: string;
    readonly developerURL?: string;
    readonly dir?: string;
    readonly lang?: string;
    readonly background?: string;
    readonly theme_color?: string;
    readonly appleStatusBarStyle?: string;
    readonly display?: string;
    readonly orientation?: string;
    readonly scope?: string;
    readonly start_url?: string;
    readonly version?: string;
    readonly pixel_art?: boolean;
    readonly loadManifestWithCredentials?: boolean;
    readonly manifestRelativePaths?: boolean;
    readonly manifestMaskable?: boolean | string | string[] | Buffer | Buffer[];
    readonly preferRelatedApplications?: boolean;
    readonly relatedApplications?: Application[];
    readonly icons?: Dictionary<IconOptions | boolean | string[]>;
    readonly files?: Dictionary<FileOptions>;
    readonly shortcuts?: ShortcutOptions[];
    readonly output?: OutputOptions;
}

interface FaviconImage {
    readonly name: string;
    readonly contents: Buffer | RawImage;
}
interface FaviconFile {
    readonly name: string;
    readonly contents: string;
}
declare const config: {
    defaults: FaviconOptions;
};
declare type FaviconHtmlElement = string;
interface FaviconResponse {
    readonly images: FaviconImage[];
    readonly files: FaviconFile[];
    readonly html: FaviconHtmlElement[];
}
/**
 * @typedef FaviconCallback
 * @type {(error: Error|null, response: FaviconResponse) => any}
 */
/**
 * Build favicons
 * @param {string|string[]|Buffer|Buffer[]} source - The path to the source image to generate icons from
 * @param {Partial<FaviconOptions>|undefined} options - The options used to build favicons
 * @param {FaviconCallback|undefined} next - The callback to execute after processing
 * @returns {Promise|Promise<FaviconResponse>}
 */
declare function favicons(source: string | string[] | Buffer | Buffer[], options?: FaviconOptions, next?: any): any;

interface FaviconStreamOptions extends FaviconOptions {
    readonly html?: string;
    readonly pipeHTML?: boolean;
    readonly emitBuffers?: boolean;
}
declare type HandleHTML = (html: FaviconHtmlElement[]) => void;
declare class FaviconStream extends Transform {
    #private;
    constructor(options: FaviconStreamOptions, handleHTML: HandleHTML);
    _transform(file: any, _encoding: any, callback: any): void;
}
declare function stream(options: FaviconStreamOptions, handleHTML: HandleHTML): FaviconStream;

export { FaviconFile, FaviconHtmlElement, FaviconImage, FaviconResponse, FaviconStreamOptions, HandleHTML, config, favicons as default, favicons, stream };
